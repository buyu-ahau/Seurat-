# 加载必要的包
library(Seurat)
library(Signac)
library(dplyr)
library(ggplot2)
library(tidyr)
library(future)
library(future.apply)

# 设置并行计算 - 使用64核中的48核（留一些核心给系统其他进程）
plan("multicore", workers = 48)
# 增加允许的内存限制，因为scATAC-seq数据较大
options(future.globals.maxSize = 50 * 1024^3)  # 50GB

# 创建保存结果的目录
output_dir <- "/disk192/users_dir/buyu/1.布宇/3.布宇scATAC-seq/2025.8.14/7.Diffpeak分析"
dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)
setwd(output_dir)

# 为数据添加一个实验组列(Infected vs Control)
obj$condition <- ifelse(grepl("Mhp", obj$orig.ident), "Infected", "Control")
cat("样本分组情况:\n")
print(table(obj$condition))

# 创建一个存储差异分析结果的列表
diff_peaks_results <- list()
up_in_infected_counts <- c()
up_in_control_counts <- c()
cell_types <- c()

# 对每个细胞类型进行差异分析
for(cell_type in unique(obj$seurat_clusters)) {
  cat(paste0("\n正在处理细胞类型: ", cell_type, "\n"))
  
  # 子集化为当前细胞类型
  cell_subset <- subset(obj, seurat_clusters == cell_type)
  
  # 检查每组细胞数量
  cell_counts <- table(cell_subset$condition)
  cat("细胞数量: Infected =", cell_counts["Infected"], ", Control =", cell_counts["Control"], "\n")
  
  # 确保每组至少有10个细胞
  if(all(cell_counts >= 10)) {
    # 设置默认assay为ATAC
    DefaultAssay(cell_subset) <- "ATAC"
    
    # 进行差异分析，启用并行计算
    cat("正在并行进行差异分析（使用48核）...\n")
    diff_peaks <- FindMarkers(
      object = cell_subset,
      group.by = "condition",
      ident.1 = "Infected",
      ident.2 = "Control",
      test.use = "LR",    # 使用逻辑回归，适合scATAC-seq数据
      latent.vars = "nCount_ATAC",  # 控制测序深度
      min.pct = 0.05,     # 至少在5%的细胞中检测到
      logfc.threshold = 0.25  # log2倍数变化阈值
    )
    
    # 添加peak名称和细胞类型
    diff_peaks$peak <- rownames(diff_peaks)
    diff_peaks$cell_type <- cell_type
    
    # 保存结果
    diff_peaks_results[[cell_type]] <- diff_peaks
    
    # 统计上下调peak数量
    up_in_infected <- sum(diff_peaks$avg_log2FC > 0 & diff_peaks$p_val_adj < 0.05)
    up_in_control <- sum(diff_peaks$avg_log2FC < 0 & diff_peaks$p_val_adj < 0.05)
    
    cat("差异peak数量: 感染组上调 =", up_in_infected, ", 对照组上调 =", up_in_control, "\n")
    
    # 保存计数
    up_in_infected_counts <- c(up_in_infected_counts, up_in_infected)
    up_in_control_counts <- c(up_in_control_counts, up_in_control)
    cell_types <- c(cell_types, cell_type)
    
    # 立即保存当前细胞类型的结果，以防程序中断
    write.csv(
      diff_peaks, 
      file = file.path(output_dir, paste0("diff_peaks_", cell_type, ".csv")),
      row.names = FALSE
    )
    cat(paste0("已保存 ", cell_type, " 的差异分析结果\n"))
  } else {
    cat("细胞数量不足，跳过差异分析\n")
  }
}

# 创建绘图数据框
plot_data <- data.frame(
  cell_type = cell_types,
  up_in_infected = up_in_infected_counts,
  up_in_control = up_in_control_counts
)

# 保存差异peak数量统计结果
write.csv(plot_data, file = file.path(output_dir, "diff_peaks_counts_summary.csv"), row.names = FALSE)

# 将数据转换为长格式用于绘图
plot_data_long <- plot_data %>%
  pivot_longer(
    cols = c(up_in_infected, up_in_control),
    names_to = "peak_type",
    values_to = "count"
  )

# 重命名peak_type以便于理解
plot_data_long$peak_type <- factor(
  plot_data_long$peak_type,
  levels = c("up_in_infected", "up_in_control"),
  labels = c("Up in Infected", "Up in Control")
)

# 创建条形图
p <- ggplot(plot_data_long, aes(x = cell_type, y = count/1000, fill = peak_type)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.7) +
  labs(
    title = "Differential Peaks between Infected and Control Groups",
    x = "Cell Type",
    y = "# Diff. Peaks (x10³)",
    fill = "Peak Type"
  ) +
  scale_fill_manual(values = c("Up in Infected" = "#E64B35", "Up in Control" = "#4DBBD5")) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
    axis.text.y = element_text(size = 12),
    axis.title = element_text(size = 14, face = "bold"),
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    legend.title = element_text(size = 12, face = "bold"),
    legend.text = element_text(size = 12),
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank()
  )

# 显示图形
print(p)

# 保存图形
ggsave(file.path(output_dir, "differential_peaks_by_cell_type.pdf"), plot = p, width = 10, height = 6)
ggsave(file.path(output_dir, "differential_peaks_by_cell_type.png"), plot = p, width = 10, height = 6, dpi = 300)

# 保存所有差异分析结果到一个文件
if(length(diff_peaks_results) > 0) {
  all_diff_peaks <- do.call(rbind, diff_peaks_results)
  write.csv(all_diff_peaks, file = file.path(output_dir, "all_diff_peaks.csv"), row.names = FALSE)
}

cat("\n差异分析完成！所有结果已保存到:", output_dir, "\n")

# 关闭并行计算
plan(sequential)





#####motif分析后   TF热图绘制
# (确保您已经加载了这些库)
library(dplyr)
library(pheatmap)
library(RColorBrewer)
library(tidyr)

# 定义颜色 (放到循环外)
plot_colors <- list(
  Control = colorRampPalette(brewer.pal(n = 9, name = "Blues"))(100),
  Infected = colorRampPalette(brewer.pal(n = 9, name = "YlOrRd"))(100)
)
# 沿用您指定的这份代码的逻辑
conditions <- c("Control", "Infected")

for(condition_to_plot in conditions) {
  
  cat(paste0("--- 开始处理: ", condition_to_plot, " ---\n"))
  
  # 1. 筛选当前条件的数据
  condition_results <- all_results[all_results$condition == condition_to_plot,]
  if(nrow(condition_results) == 0) {
    cat(paste0("警告: 未找到 ", condition_to_plot, " 组的任何数据。\n")); next
  }
  
  # 2. 筛选p值显著的TFs
  sig_tfs <- condition_results[condition_results$"P-value" < 0.05,]
  if(nrow(sig_tfs) == 0) {
    cat(paste0("警告: 在 ", condition_to_plot, " 组中未找到p<0.05的显著富集TFs。\n")); next
  }
  
  # 3. 为每个细胞类型选择Top 15的TFs
  top_tfs <- sig_tfs %>%
    group_by(cell_type) %>%
    slice_min(order_by = `P-value`, n = 15) %>%
    ungroup()
  if(nrow(top_tfs) == 0) {
    cat(paste0("警告: 在 ", condition_to_plot, " 组中筛选Top 15 TFs后结果为空。\n")); next
  }

  # 4. 创建热图矩阵 (TF x 细胞)
  heatmap_data <- top_tfs %>%
    select(cell_type, `Motif Name`, `Log P-value`) %>%
    mutate(value = -`Log P-value`) %>%
    select(-`Log P-value`) %>%
    pivot_wider(names_from = cell_type, values_from = value, values_fill = 0) %>%
    as.data.frame()
  rownames(heatmap_data) <- heatmap_data$`Motif Name`
  heatmap_data <- heatmap_data[,-1] %>% as.matrix()

  # 5. 过滤掉只在1个细胞中富集的TF
  keep_rows <- rowSums(heatmap_data > 0) >= 2
  heatmap_data_filtered <- heatmap_data[keep_rows, , drop = FALSE]
  
  # 检查过滤后是否还有足够的数据
  if(nrow(heatmap_data_filtered) < 2 || ncol(heatmap_data_filtered) < 2) {
      cat("数据不足，无法进行聚类和绘图。\n"); next
  }

  # 6. 简化TF名称
  short_tf_names <- sub("[(/].*", "", rownames(heatmap_data_filtered))
  rownames(heatmap_data_filtered) <- short_tf_names
  
  # 7. 转置矩阵 (细胞 x TF)
  heatmap_data_transposed <- t(heatmap_data_filtered)
  
  # ---【核心修改从这里开始】---
  
  cat("正在计算聚类排序...\n")
  
  # 8. 【第1步】在后台对包含0的原始数据进行聚类，以获取排序树
  # silent = TRUE 是关键，它只计算，不画图
  clustering_results <- pheatmap(
    heatmap_data_transposed,
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    silent = TRUE 
  )
  
  # 9. 【第2步】准备用于绘图的矩阵：将0替换为NA
  plot_matrix <- heatmap_data_transposed
  plot_matrix[plot_matrix == 0] <- NA
  
  cat("正在生成最终热图...\n")
  
  # 10. 【第3步】使用预先计算好的聚类树来绘制带NA的矩阵
  pheatmap(
    plot_matrix, # 使用带NA的矩阵进行绘图
    color = plot_colors[[condition_to_plot]],
    main = paste("Enriched Motifs in Peaks Up in", condition_to_plot),
    
    # --- 美化参数 ---
    na_col = "white",      # 将NA值设为白色背景
    cellwidth = 12,        # 设置格子宽度
    cellheight = 12,       # 设置格子高度
    border_color = "grey80",
    fontsize = 8,
    angle_col = 90,
    
    # --- 关键：使用预计算的聚类结果 ---
    cluster_rows = clustering_results$tree_row,
    cluster_cols = clustering_results$tree_col,
    
    filename = paste0("TF_enrichment_", condition_to_plot, "_final_v2.pdf")
  )
  # ---【核心修改在这里结束】---
}

cat("--- 所有热图处理完成！ ---\n")




# --- 2. 循环绘图 ---

# 【核心修改】定义颜色时，截取调色板，跳过最浅的颜色
plot_colors <- list(
  # 对于蓝色系，我们从第3种蓝色开始，到第9种结束
  Control = colorRampPalette(brewer.pal(n = 9, name = "Blues")[3:9])(100),
  # 对于黄橙红系，也从第3种颜色（橙色）开始，跳过最浅的黄色
  Infected = colorRampPalette(brewer.pal(n = 9, name = "YlOrRd")[3:9])(100)
)

# 沿用您指定的这份代码的逻辑
conditions <- c("Control", "Infected")

for(condition_to_plot in conditions) {
  # ... (您之前脚本中循环内部的数据准备部分保持不变) ...
  # 为了代码完整性，我将整个循环都贴在下方，您直接复制替换即可
  
  cat(paste0("--- 开始处理: ", condition_to_plot, " ---\n"))
  
  # 1. 数据准备
  condition_results <- all_results[all_results$condition == condition_to_plot,]
  if(nrow(condition_results) == 0) { next }
  sig_tfs <- condition_results[condition_results$"P-value" < 0.05,]
  if(nrow(sig_tfs) == 0) { next }
  top_tfs <- sig_tfs %>% group_by(cell_type) %>% slice_min(order_by = `P-value`, n = 15) %>% ungroup()
  if(nrow(top_tfs) == 0) { next }
  heatmap_data <- top_tfs %>% select(cell_type, `Motif Name`, `Log P-value`) %>% mutate(value = -`Log P-value`) %>% select(-`Log P-value`) %>% pivot_wider(names_from = cell_type, values_from = value, values_fill = 0) %>% as.data.frame()
  rownames(heatmap_data) <- heatmap_data$`Motif Name`
  heatmap_data <- heatmap_data[,-1] %>% as.matrix()
  keep_rows <- rowSums(heatmap_data > 0) >= 2
  heatmap_data_filtered <- heatmap_data[keep_rows, , drop = FALSE]
  if(nrow(heatmap_data_filtered) < 2 || ncol(heatmap_data_filtered) < 2) { next }
  short_tf_names <- sub("[(/].*", "", rownames(heatmap_data_filtered))
  rownames(heatmap_data_filtered) <- short_tf_names
  heatmap_data_transposed <- t(heatmap_data_filtered)
  
  # 2. 后台聚类计算
  clustering_results <- pheatmap(
    heatmap_data_transposed,
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    silent = TRUE 
  )
  
  # 3. 准备绘图矩阵 (0 -> NA)
  plot_matrix <- heatmap_data_transposed
  plot_matrix[plot_matrix == 0] <- NA
  
  # 4. 绘图
  pheatmap(
    plot_matrix, 
    color = plot_colors[[condition_to_plot]], # 使用新的颜色方案
    main = paste("Enriched Motifs in Peaks Up in", condition_to_plot),
    na_col = "white",
    cellwidth = 12,
    cellheight = 12,
    border_color = "grey80",
    fontsize = 8,
    angle_col = 90,
    cluster_rows = clustering_results$tree_row,
    cluster_cols = clustering_results$tree_col,
    filename = paste0("TF_enrichment_", condition_to_plot, "_deeper_color.pdf")
  )
}

cat("--- 所有热图处理完成！ ---\n")